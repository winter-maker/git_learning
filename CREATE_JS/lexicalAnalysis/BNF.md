- 认识产生式
- 产生式
- 产生式是程序性知识的最小表征方式，是指人脑中贮存的一系列如果—那么形式表示的规则

- 外星语
- symbol
- terminalSymbol 终结符: 不可以再分的字符和串。js 中用引号引起来 "pa" "gu"
- nonTerminalSymbol 非终结符：可以再分的字符和串。js 中用词表示 <word>
- 巴克斯诺尔范式写法：
  <wrod> :== "pa" | "gu"
  - 表示一个或多个
  * 表示 0 个或多个
    [] 表示可省略

# 表示多个 wrod

- 递归的写法
  <language> :== <wrod><language> | <wrod>
- 简化的写法
  <language> :== <wrod>+

case1: "gu" 只会两个或三个同时出现，"pa"出现无规律
<wrod> ::= "pa"\* | "gu" "gu" | "gu" "gu" "gu"
<language> ::= <wrod>+

case2: 满足下面三个条件
1、"pa" "gu" "gu"
2、"gu" "gu" "gu" "pa"
3、并且 pa 不能连续出现

<a> ::= "pa" "gu" "gu"
<b> ::= "gu" "gu" "gu" "pa"
<language> ::= <a>+ | <b>+ | <a>+<b>+

case3: case2 基础上多了一个 <c> ::= "pa",规则和 case2 一样
<a> ::= "pa" "gu" "gu"
<b> ::= "gu" "gu" "gu" "pa"
<c> ::= "pa"
<language> ::= <a>+ | <b>+ | <a>_<c><b>_ | <a>+<b>+

case4: 增加条件，<a> 和 <b> 的数量必须相等
<d> ::= <a>[<c>]<b> | <c>
<language> ::= <d>+

//递归
<d> ::= <a>[<d>]<b> | <c>
<language> ::= <d>\*

联想：假如 <a> 和 <b> 不是外星语，而是括号，是不是我们就可以用来描述说这个语言里的括号必须配对

case5: 匹配合法的括号
1、()[]{}
2、()()
3、()[]
4、([)] 不合法
5、(([{}]))
<d> ::= <a> | <b> | <c>
<a> ::= "(" <d>\* ")"
<b> ::= "[" <d>\* "]"
<c> ::= "{" <d>\* "}"
<language> ::= <d>+

乔姆斯基文法：

1、一型文法：自由文法,
"a" "c" "b" ::= "d" 一个终结符产三个终结符

2、二型文法：上下文相关文法，
"a" <word> <b> = "a" "pa" "gu" <b>
表示"a"和<b>被认为是<word>的上下文, 在上下文特定的 "a"和<b>中间，"pa""gu"可以被转为<word>

3、三型文法：上下文无关文法
// syntactial grammar, syntax , parser
语法分析
<word> ::= "pa" "gu"
左侧只有一个非终结符

4、四型文法：正则文法：能用正则表达式解析的文法，比三型文法更简单。case5 括号配对正则文法是没办法处理的，有人尝试使用正则文法校验 html,标签匹配他是匹配不了的。html 也不是正则文法。html 要比正则复杂。现代语言通常使用正则文法就行一个预处理，进行一个分词，这个个过程叫做 lexical grammar 。
词法分析
// lexical grammar, lex, lexar 指处理正则文法的词法分析器

大部分的计算机语言都属于三型和四型文法。自然语言多数位于一型文法和二型文法。
